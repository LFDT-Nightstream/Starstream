#![allow(non_camel_case_types)]

use std::{
    collections::BTreeMap,
    ops::{Add, Mul, Sub},
};

use crate::interface::{Circuit, CircuitBuilder, CircuitBuilderVar, Location};

type LinFun = BTreeMap<u32, (i128, i128)>;

/// R1CS with memory and lookups,
/// not represented as three explicit big matrices.
#[derive(Debug)]
pub struct R1CS {
    pub n_io: u32,
    pub n_witnesses: u32,
    pub constraints: Vec<(LinFun, LinFun, LinFun)>,
    pub lookups: Vec<(u32, LinFun, LinFun)>,
    pub memory_ops: Vec<(u32, LinFun, LinFun, LinFun)>,
}

// generated by Grok 4
fn union_with<K: Ord, V>(
    dest: &mut BTreeMap<K, V>,
    src: impl Iterator<Item = (K, V)>,
    mut merge: impl FnMut(&mut V, V),
) {
    for (k, v) in src {
        if let Some(existing) = dest.get_mut(&k) {
            merge(existing, v);
        } else {
            dest.insert(k, v);
        }
    }
}

pub fn gen_r1cs_structure<IO, L, M>(
    circuit: impl Circuit<IO, L, M>,
    n_io: u32,
    io_mapping: impl Fn(IO) -> u32,
    l_mapping: impl Fn(L) -> u32,
    m_mapping: impl Fn(M) -> u32,
) -> R1CS {
    // A "variable" is less a variable and more a possibly unfinished
    // linear function on the input vector of variables,
    // i.e. of the form c_0 * v_0 + c_1 * v_1 + ... + c_n * v_n,
    // where v_0 is conventionally taken to be 1.
    // Each entry of this BTreeMap specifies the constant (i128) for
    // the variable specified by the index.
    // A non-existent entry means the constant is zero,
    // albeit zero entries may also exist if you do x - x.
    #[derive(Clone, Debug)]
    struct Var(LinFun);

    impl From<i128> for Var {
        fn from(n: i128) -> Self {
            Var([(0, (n, 1))].into_iter().collect())
        }
    }

    impl From<(i128, i128)> for Var {
        fn from((n, d): (i128, i128)) -> Self {
            Var([(0, (n, d))].into_iter().collect())
        }
    }

    impl Add<Var> for Var {
        type Output = Var;
        fn add(self, Var(rhs): Var) -> Self::Output {
            let Var(mut lhs) = self;
            union_with(&mut lhs, rhs.into_iter(), |x, (y_n, y_d)| {
                let (x_n, x_d) = *x;
                let r = if x_d == y_d {
                    (x_n + y_n, x_d)
                } else {
                    let d = x_d * y_d;
                    let x_n = x_n * y_d;
                    let y_n = y_n * x_d;
                    (x_n + y_n, d)
                };
                *x = r;
            });
            Var(lhs)
        }
    }

    impl Add<i128> for Var {
        type Output = Var;
        fn add(self, rhs: i128) -> Self::Output {
            self + Var::from(rhs)
        }
    }

    impl Add<(i128, i128)> for Var {
        type Output = Var;
        fn add(self, rhs: (i128, i128)) -> Self::Output {
            self + Var::from(rhs)
        }
    }

    impl Sub<Var> for Var {
        type Output = Var;
        fn sub(self, Var(rhs): Var) -> Self::Output {
            let Var(mut lhs) = self;
            union_with(&mut lhs, rhs.into_iter(), |x, (y_n, y_d)| {
                let (x_n, x_d) = *x;
                let r = if x_d == y_d {
                    (x_n - y_n, x_d)
                } else {
                    let d = x_d * y_d;
                    let x_n = x_n * y_d;
                    let y_n = y_n * x_d;
                    (x_n - y_n, d)
                };
                *x = r;
            });
            Var(lhs)
        }
    }

    impl Sub<i128> for Var {
        type Output = Var;
        fn sub(self, rhs: i128) -> Self::Output {
            self - Var::from(rhs)
        }
    }

    impl Sub<(i128, i128)> for Var {
        type Output = Var;
        fn sub(self, rhs: (i128, i128)) -> Self::Output {
            self - Var::from(rhs)
        }
    }

    impl Mul<i128> for Var {
        type Output = Var;
        fn mul(self, rhs: i128) -> Self::Output {
            let Var(lhs) = self;
            Var(lhs
                .into_iter()
                .map(|(i, (c_n, c_d))| (i, (c_n * rhs, c_d)))
                .collect())
        }
    }

    impl Mul<(i128, i128)> for Var {
        type Output = Var;
        fn mul(self, (n, d): (i128, i128)) -> Self::Output {
            let Var(lhs) = self;
            Var(lhs
                .into_iter()
                .map(|(i, (c_n, c_d))| (i, (c_n * n, c_d * d)))
                .collect())
        }
    }

    impl CircuitBuilderVar for Var {}

    struct Builder<'a, io_mapping, l_mapping, m_mapping> {
        constraints: &'a mut Vec<(LinFun, LinFun, LinFun)>,
        lookups: &'a mut Vec<(u32, LinFun, LinFun)>,
        memory_ops: &'a mut Vec<(u32, LinFun, LinFun, LinFun)>,
        witness_counter: &'a mut u32,
        n_io: u32,
        io_mapping: io_mapping,
        l_mapping: l_mapping,
        m_mapping: m_mapping,
    }

    impl<'a, IO, L, M, io_mapping, l_mapping, m_mapping> CircuitBuilder<Var, IO, L, M>
        for Builder<'a, io_mapping, l_mapping, m_mapping>
    where
        io_mapping: Fn(IO) -> u32,
        l_mapping: Fn(L) -> u32,
        m_mapping: Fn(M) -> u32,
    {
        fn alloc(&mut self, _: Location) -> Var {
            let i = *self.witness_counter;
            *self.witness_counter += 1;
            Var([(self.n_io + i, (1, 1))].into_iter().collect())
        }
        fn enforce(&mut self, _: Location, Var(a): Var, Var(b): Var, Var(c): Var) {
            self.constraints.push((a, b, c));
        }
        fn lookup(&mut self, namespace: L, Var(index): Var, Var(value): Var) {
            self.lookups
                .push(((self.l_mapping)(namespace), index, value));
        }
        fn memory(&mut self, namespace: M, Var(address): Var, Var(old): Var, Var(new): Var) {
            self.memory_ops
                .push(((self.m_mapping)(namespace), address, old, new));
        }
        fn nest<'b>(&'b mut self, _: Location) -> impl CircuitBuilder<Var, IO, L, M> + 'b {
            Builder {
                constraints: self.constraints,
                lookups: self.lookups,
                memory_ops: self.memory_ops,
                witness_counter: self.witness_counter,
                n_io: self.n_io,
                io_mapping: &self.io_mapping,
                l_mapping: &self.l_mapping,
                m_mapping: &self.m_mapping,
            }
        }
        fn assert_size(&mut self, _: (u32, u32)) {}
        fn input(&mut self, name: IO) -> Var {
            Var([((self.io_mapping)(name), (1, 1))].into_iter().collect())
        }
        fn output(&mut self, name: IO) -> Var {
            Var([((self.io_mapping)(name) + self.n_io, (1, 1))]
                .into_iter()
                .collect())
        }
        fn link(&mut self, x: Var, y: Var) {
            unimplemented!("FIXME")
        }
    }

    let mut constraints = Vec::new();
    let mut lookups = Vec::new();
    let mut memory_ops = Vec::new();
    let mut witness_counter = 0;

    let builder = Builder {
        constraints: &mut constraints,
        lookups: &mut lookups,
        memory_ops: &mut memory_ops,
        witness_counter: &mut witness_counter,
        n_io,
        io_mapping,
        l_mapping,
        m_mapping,
    };
    circuit.run(builder);

    R1CS {
        n_io,
        n_witnesses: witness_counter,
        constraints,
        lookups,
        memory_ops,
    }
}
