use std::{
    collections::BTreeMap,
    ops::{Add, Mul, Sub},
};

use crate::interface::{Circuit, CircuitBuilder, CircuitBuilderVar, Location};

#[derive(Debug)]
pub struct R1CS {
    // A, B, C: F^(n_constraints * (1 + n_io + n_witnesses))
    // z: F^(1 + n_io + n_witnesses)
    pub n_io: usize,
    pub n_witnesses: usize,
    pub n_constraints: usize,
    // len(structure) = (1 + n_io + n_witnesses) * n_constraints * 3
    // order is as above, that is,
    // first split into 3 for the three matrices A, B, C,
    // then split into n_constraints rows,
    // then split into (1 + n_io + n_witnesses) entries,
    // such that you can read row by row, starting from A, then B, then C.
    pub structure: Box<[i128]>,
}

fn calculate_dimensions(c: &impl Circuit, n_io: usize) -> (usize, usize) {
    #[derive(Clone, Debug)]
    struct Var;

    impl Add<Var> for Var {
        type Output = Var;
        fn add(self, Var: Var) -> Self::Output {
            Var
        }
    }

    impl Sub<Var> for Var {
        type Output = Var;
        fn sub(self, Var: Var) -> Self::Output {
            Var
        }
    }

    impl Mul<i128> for Var {
        type Output = Var;
        fn mul(self, _: i128) -> Self::Output {
            Var
        }
    }

    impl CircuitBuilderVar for Var {}

    struct Builder<'a> {
        n_witnesses: &'a mut usize,
        n_constraints: &'a mut usize,
    }

    impl<'a> CircuitBuilder<Var> for Builder<'a> {
        fn zero(&mut self) -> Var {
            Var
        }
        fn one(&mut self) -> Var {
            Var
        }
        fn lit(&mut self, _: i128) -> Var {
            Var
        }
        fn alloc(&mut self, _: Location) -> Var {
            *self.n_witnesses += 1;
            Var
        }
        fn enforce(&mut self, _: Location, _: Var, _: Var, _: Var) {
            *self.n_constraints += 1;
        }
        fn lookup(&mut self, _: Var, _: Var, _: Var) {}
        fn memory(&mut self, _: Var, _: Var, _: Var, _: Var) {}
        fn nest<'b>(&'b mut self, _: Location) -> impl CircuitBuilder<Var> + 'b {
            Builder {
                n_witnesses: self.n_witnesses,
                n_constraints: self.n_constraints,
            }
        }
    }

    let mut n_witnesses = 0;
    let mut n_constraints = 0;
    let io = vec![Var; n_io];
    let builder = Builder {
        n_witnesses: &mut n_witnesses,
        n_constraints: &mut n_constraints,
    };
    c.run(builder, io);

    (n_witnesses, n_constraints)
}

// generated by Grok 4
fn union_with<K: Ord, V>(
    dest: &mut BTreeMap<K, V>,
    src: impl Iterator<Item = (K, V)>,
    mut merge: impl FnMut(&mut V, V),
) {
    for (k, v) in src {
        if let Some(existing) = dest.get_mut(&k) {
            merge(existing, v);
        } else {
            dest.insert(k, v);
        }
    }
}

fn calculate_structure(
    c: &impl Circuit,
    n_io: usize,
    n_witnesses: usize,
    n_constraints: usize,
) -> Box<[i128]> {
    // A "variable" is less a variable and more a possibly unfinished
    // linear function on the input vector of variables,
    // i.e. of the form c_0 * v_0 + c_1 * v_1 + ... + c_n * v_n,
    // where v_0 is conventionally taken to be 1.
    // Each entry of this BTreeMap specifies the constant (i128) for
    // the variable specified by the index.
    // A non-existent entry means the constant is zero,
    // albeit zero entries may also exist if you do x - x.
    #[derive(Clone, Debug)]
    struct Var(BTreeMap<usize, i128>);

    impl Add<Var> for Var {
        type Output = Var;
        fn add(self, Var(rhs): Var) -> Self::Output {
            let Var(mut lhs) = self;
            union_with(&mut lhs, rhs.into_iter(), |x, y| {
                *x += y;
            });
            Var(lhs)
        }
    }

    impl Sub<Var> for Var {
        type Output = Var;
        fn sub(self, Var(rhs): Var) -> Self::Output {
            let Var(mut lhs) = self;
            union_with(&mut lhs, rhs.into_iter().map(|(i, c)| (i, -c)), |x, y| {
                *x += y;
            });
            Var(lhs)
        }
    }

    impl Mul<i128> for Var {
        type Output = Var;
        fn mul(self, rhs: i128) -> Self::Output {
            let Var(lhs) = self;
            Var(lhs.into_iter().map(|(i, c)| (i, c * rhs)).collect())
        }
    }

    impl CircuitBuilderVar for Var {}

    struct Builder<'a> {
        structure: &'a mut [i128],
        witness_counter: &'a mut usize,
        constraint_counter: &'a mut usize,
        n_io: usize,
        n_witnesses: usize,
        n_constraints: usize,
    }

    impl<'a> CircuitBuilder<Var> for Builder<'a> {
        fn zero(&mut self) -> Var {
            Var(BTreeMap::new())
        }
        fn one(&mut self) -> Var {
            Var([(0, 1)].into_iter().collect())
        }
        fn lit(&mut self, n: i128) -> Var {
            Var([(0, n)].into_iter().collect())
        }
        fn alloc(&mut self, _: Location) -> Var {
            let i = *self.witness_counter;
            assert!(i < self.n_witnesses);
            *self.witness_counter += 1;
            Var([(i, 1)].into_iter().collect())
        }
        fn enforce(&mut self, _: Location, Var(a): Var, Var(b): Var, Var(c): Var) {
            let row_size = 1 + self.n_io + self.n_witnesses;
            let n_rows = self.n_constraints;
            let matrix_size = row_size * n_rows;
            let row = *self.constraint_counter;
            assert!(row < self.n_constraints);
            *self.constraint_counter += 1;
            for (col, coeff) in a {
                self.structure[row * row_size + col] = coeff;
            }
            for (col, coeff) in b {
                self.structure[matrix_size + row * row_size + col] = coeff;
            }
            for (col, coeff) in c {
                self.structure[matrix_size * 2 + row * row_size + col] = coeff;
            }
        }
        fn lookup(&mut self, _: Var, _: Var, _: Var) {}
        fn memory(&mut self, _: Var, _: Var, _: Var, _: Var) {}
        fn nest<'b>(&'b mut self, _: Location) -> impl CircuitBuilder<Var> + 'b {
            Builder {
                structure: self.structure,
                witness_counter: self.witness_counter,
                constraint_counter: self.constraint_counter,
                n_io: self.n_io,
                n_witnesses: self.n_witnesses,
                n_constraints: self.n_constraints,
            }
        }
    }

    let mut structure =
        vec![0i128; n_constraints * (1 + n_witnesses + n_io) * 3].into_boxed_slice();
    let mut witness_counter = 0;
    let mut constraint_counter = 0;

    let io = (1..=n_io)
        .map(|i| Var([(i, 1)].into_iter().collect()))
        .collect();
    let builder = Builder {
        structure: &mut structure,
        witness_counter: &mut witness_counter,
        constraint_counter: &mut constraint_counter,
        n_io,
        n_witnesses,
        n_constraints,
    };
    c.run(builder, io);

    assert_eq!(witness_counter, n_witnesses);
    assert_eq!(constraint_counter, n_constraints);

    structure
}

pub fn gen_r1cs_structure(circuit: impl Circuit, n_io: usize) -> R1CS {
    let (n_witnesses, n_constraints) = calculate_dimensions(&circuit, n_io);
    let structure = calculate_structure(&circuit, n_io, n_witnesses, n_constraints);
    R1CS {
        n_io,
        n_witnesses,
        n_constraints,
        structure,
    }
}
