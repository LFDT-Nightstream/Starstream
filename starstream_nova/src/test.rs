use std::{
    fmt::Display,
    ops::{Add, Mul, Sub},
};

use crate::interface::{Circuit, CircuitBuilder, CircuitBuilderVar, Location};

#[derive(Clone, Copy)]
pub enum Locations<'a> {
    Nil,
    Cons {
        tag: u64,
        head: Location,
        tail: &'a Locations<'a>,
    },
}

impl<'a> Display for Locations<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Locations::Nil => write!(f, "!"),
            Locations::Cons { tag: _, head, tail } => {
                write!(f, "{}:{}.", head.label, head.line)?;
                tail.fmt(f)
            }
        }
    }
}

fn cons<'a>(head: Location, tail: &'a Locations<'a>) -> Locations<'a> {
    const C: u64 = 6872849445662101858;
    match tail {
        Locations::Nil => Locations::Cons {
            tag: head.tag,
            head,
            tail,
        },
        Locations::Cons {
            tag: tail_tag,
            head: _,
            tail: _,
        } => {
            let tag = match (head.tag, *tail_tag) {
                (tag, 0) => tag,
                (0, tag) => tag,
                (head_tag, tail_tag) => tail_tag.wrapping_mul(C).wrapping_add(head_tag),
            };
            Locations::Cons { tag, head, tail }
        }
    }
}

fn calculate_tag(locations: Locations<'_>) -> u64 {
    match locations {
        Locations::Nil => 0,
        Locations::Cons { tag, .. } => tag,
    }
}

// grok generated goldilocks impl
const P: u128 = 0xFFFFFFFF00000001u128;

fn add(a: u64, b: u64) -> u64 {
    let sum = a as u128 + b as u128;
    if sum >= P {
        (sum - P) as u64
    } else {
        sum as u64
    }
}

fn neg(a: u64) -> u64 {
    if a == 0 { 0 } else { (P - a as u128) as u64 }
}

fn mul(a: u64, b: u64) -> u64 {
    let prod = a as u128 * b as u128;
    (prod % P) as u64
}

fn of_i128(n: i128) -> u64 {
    if n >= P as i128 {
        panic!("literal too big to fit in field");
    } else if n <= -(P as i128) {
        panic!("literal too small to fit in field");
    } else if n >= 0 {
        n as u64
    } else {
        (P as i128 + n) as u64
    }
}

fn of_i128_rat((n, d): (i128, i128)) -> u64 {
    mul(of_i128(n), inverse(of_i128(d)))
}

// this function was generated by Grok 4
fn inverse(a: u64) -> u64 {
    if a == 0 {
        panic!("Cannot invert zero");
    }
    let mut t: i128 = 0;
    let mut nt: i128 = 1;
    let mut r: i128 = P as i128;
    let mut nr: i128 = a as i128;
    while nr != 0 {
        let q = r / nr;
        let temp_t = nt;
        nt = t - q * nt;
        t = temp_t;
        let temp_r = nr;
        nr = r - q * nr;
        r = temp_r;
    }
    if r > 1 {
        panic!("Element is not invertible");
    }
    if t < 0 {
        t += P as i128;
    }
    t as u64
}

// TODO: maybe present as rational if that is somehow calculable?
fn pretty(n: u64) -> i128 {
    if n as u128 <= P / 2 {
        n as i128
    } else {
        -((P - n as u128) as i128)
    }
}

pub trait Handler {
    fn failed_enforce(
        &mut self,
        locations: Locations<'_>,
        lhs: i128,
        rhs: i128,
        actual: i128,
        expected: i128,
    );
    fn lookup(&mut self, locations: Locations<'_>, namespace: i128, address: i128, val: i128);
    fn invalid_memory(
        &mut self,
        locations: Locations<'_>,
        namespace: i128,
        address: i128,
        expected: i128,
        actual: i128,
        new: i128,
    );
    fn mismatching_witness(
        &mut self,
        locations: Locations<'_>,
        provided_tag: u64,
        expected_tag: u64,
    );
    fn missing_witness(&mut self, locations: Locations<'_>, expected_tag: u64);
}

pub fn test_circuit_goldilocks<IO, C: Circuit<IO>>(
    input: impl Fn(IO) -> (i128, i128),
    output: impl Fn(IO) -> (i128, i128),
    circuit: C,
    mut witness: impl Iterator<Item = (u64, (i128, i128))>,
    mut handler: impl Handler,
    memories: Vec<Vec<(i128, i128)>>,
) {
    #[derive(Clone, Copy, Debug)]
    struct Var(u64);

    impl Add<Var> for Var {
        type Output = Var;
        fn add(self, Var(rhs): Var) -> Var {
            Var(add(self.0, rhs))
        }
    }

    impl Sub<Var> for Var {
        type Output = Var;
        fn sub(self, Var(rhs): Var) -> Var {
            Var(add(self.0, neg(rhs)))
        }
    }

    impl Mul<(i128, i128)> for Var {
        type Output = Var;
        fn mul(self, (n, d): (i128, i128)) -> Var {
            Var(mul(mul(self.0, of_i128(n)), inverse(of_i128(d))))
        }
    }

    impl Mul<i128> for Var {
        type Output = Var;
        fn mul(self, rhs: i128) -> Var {
            Var(mul(self.0, of_i128(rhs)))
        }
    }

    impl CircuitBuilderVar for Var {}

    struct Builder<'a, W, H> {
        locations: Locations<'a>,
        witness: &'a mut W,
        handler: &'a mut H,
        memories: &'a mut Vec<Vec<u64>>,
        witness_count: &'a mut usize,
    }

    impl<'a, W: Iterator<Item = (u64, (i128, i128))>, H: Handler> CircuitBuilder<Var>
        for Builder<'a, W, H>
    {
        fn zero(&mut self) -> Var {
            Var(0)
        }
        fn one(&mut self) -> Var {
            Var(1)
        }
        fn lit(&mut self, n: i128) -> Var {
            Var(of_i128(n))
        }
        fn lit_rat(&mut self, n: i128, d: i128) -> Var {
            Var(of_i128_rat((n, d)))
        }
        fn alloc(&mut self, location: Location) -> Var {
            *self.witness_count += 1;
            let locations = cons(location, &self.locations);
            let expected_tag = calculate_tag(locations);
            match self
                .witness
                .next()
                .map(|(tag, n_d)| (tag, of_i128_rat(n_d)))
            {
                Some((tag @ 1..=u64::MAX, val)) => {
                    if tag != expected_tag {
                        self.handler
                            .mismatching_witness(locations, tag, expected_tag);
                    }
                    Var(val)
                }
                Some((0, val @ 1..=u64::MAX)) => {
                    self.handler.mismatching_witness(locations, 0, expected_tag);
                    Var(val)
                }
                Some((0, 0)) => Var(0),
                None => {
                    self.handler.missing_witness(locations, expected_tag);
                    Var(0)
                }
            }
        }
        fn enforce(&mut self, location: Location, Var(a): Var, Var(b): Var, Var(a_times_b): Var) {
            let locations = cons(location, &self.locations);
            let r = mul(a, b);
            if r != a_times_b {
                self.handler.failed_enforce(
                    locations,
                    pretty(a),
                    pretty(b),
                    pretty(r),
                    pretty(a_times_b),
                );
            }
        }
        fn lookup(&mut self, Var(namespace): Var, Var(address): Var, Var(val): Var) {
            self.handler.lookup(
                self.locations,
                pretty(namespace),
                pretty(address),
                pretty(val),
            );
        }
        fn memory(&mut self, Var(namespace): Var, Var(address): Var, Var(old): Var, Var(new): Var) {
            self.memories
                .resize_with(namespace as usize + 1, Vec::default);
            let m = &mut self.memories[namespace as usize];
            m.resize_with(address as usize + 1, u64::default);
            let old_ = m[address as usize];
            if old_ != old {
                self.handler.invalid_memory(
                    self.locations,
                    pretty(namespace),
                    pretty(address),
                    pretty(old),
                    pretty(old_),
                    pretty(new),
                );
            }
            m[address as usize] = new;
        }
        fn nest<'b>(&'b mut self, location: Location) -> impl CircuitBuilder<Var> + 'b {
            Builder {
                locations: cons(location, &self.locations),
                witness: self.witness,
                handler: self.handler,
                memories: self.memories,
                witness_count: self.witness_count,
            }
        }
        fn assert_offset(&mut self, offset: usize) {
            // FIXME: emit location on failure
            assert_eq!(*self.witness_count, offset);
        }
    }

    let mut memories = memories
        .into_iter()
        .map(|memory| memory.into_iter().map(of_i128_rat).collect())
        .collect();

    let builder = Builder {
        locations: Locations::Nil,
        witness: &mut witness,
        handler: &mut handler,
        memories: &mut memories,
        witness_count: &mut 0,
    };

    circuit.run(
        builder,
        move |idx| Var(of_i128_rat(input(idx))),
        move |idx| Var(of_i128_rat(output(idx))),
    );
}
