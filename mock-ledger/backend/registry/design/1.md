# Decentralized WIT Package Storage Design

This document describes the design and implementation approaches for managing WIT package dependencies in the Starstream blockchain ledger. It provides comprehensive context for making implementation decisions and serves as a reference for developers working on this system.

---

# Part 1: Problem Statement and Design Goals

## Starstream Overview

Starstream is a **UTXO-based blockchain** where **smart contracts are WebAssembly Components**. Unlike account-based blockchains (Ethereum), Starstream uses a UTXO (Unspent Transaction Output) model where each smart contract instance is an independent, immutable output.

### Core Architecture

```
┌─────────────────────────────────────────────────────┐
│ NODE CLIENT (node-client)                           │
│ - CLI/RPC client for calling contracts              │
│ - Pulls WIT from registry to get type info          │
│ - Encodes parameters using wRPC wave encoding       │
└──────────────────┬──────────────────────────────────┘
                   │ wRPC over TCP
                   │
┌──────────────────▼──────────────────────────────────┐
│ NODE SERVER (node-server)                           │
│ - Accepts wRPC calls over TCP                       │
│ - Routes through wrpc-multiplexer                   │
│ - Instantiates and executes WASM components         │
│ - Manages ledger state                              │
└──────┬──────────────┬──────────────────┬────────────┘
       │              │                  │
  ┌────▼────┐    ┌────▼─────┐     ┌─────▼──────┐
  │ Ledger  │    │ Registry │     │Multiplexer │
  │ Chain   │    │WIT Lookup│     │ Handler    │
  └─────────┘    └──────────┘     └────────────┘
       │
  ┌────▼─────────────────────────────────────────┐
  │ UTXO Registry                                 │
  │ HashMap<UtxoId, UtxoInstance>                 │
  │ - Stores instantiated WASM Components         │
  │ - Contains datum (contract state)             │
  └───────────────────────────────────────────────┘
```

### UTXO Structure

Each UTXO (smart contract instance) is identified by:

```rust
// /mock-ledger/backend/ledger/src/utxo.rs
pub struct UtxoId {
    contract_hash: String,  // Poseidon2 hash of component bytes, e.g., "0x1170FAD15BECBB08..."
    serial: u64,            // nth occurrence of this contract_hash on chain
}

pub struct UtxoInstance {
    pub wasm_instance: Arc<InstancePre<Ctx>>,  // Cached, pre-instantiated WASM Component
    pub datum: Vec<u8>,                         // UTXO state (Component Model value encoding)
}
```

**Contract Hash**: Computed using **Poseidon2 hash over Goldilocks field** of the component bytes:
```rust
let digest = poseidon2_hash_bytes(component_bytes);
let contract_hash = format!("0x{:016X}{:016X}{:016X}{:016X}",
    digest[0].as_canonical_u64(),
    digest[1].as_canonical_u64(),
    digest[2].as_canonical_u64(),
    digest[3].as_canonical_u64()
);
```

However, the core ideas is that we consider contract hash and WIT package hashes as separate hashes

### How Clients Discover Contract Types

When a dApp wants to call a smart contract, it needs to know the function signatures and types. The client:

1. Queries the registry via wRPC: `registry::handler::get_wit(contract_hash, resolve=true)`
2. Receives the WIT definition as a string
3. Parses the WIT at runtime using `wit-parser`
4. Encodes parameters using the discovered types

```rust
// /mock-ledger/backend/node-client/src/main.rs
let interface = rpc::bindings::starstream::registry::handler::get_wit(
    &wrpc, (), &contract_hash, true,
).await?;

let mut resolve = Resolve::new();
let main = resolve.push_str(interface.entrypoint.clone(), &interface.wit)?;
let func_type = get_func_type(&resolve, &main, &func_name)?;
```

### Current Registry Implementation (Simplified Mock)

```rust
// /mock-ledger/backend/registry/src/lib.rs
pub struct ComponentInterface {
    pub wit: String,       // Full WIT definition as string
    pub entrypoint: String // Default export name (e.g., "root")
}

pub struct Registry {
    entries: Arc<RwLock<HashMap<String, ComponentInterface>>>,  // contract_hash -> WIT
}
```

This works for the mock ledger but has a fundamental scaling problem.

---

## The Problem: Flattened WIT Files and Duplication

### Background: WIT Dependencies

WIT (WebAssembly Interface Type) files can import other WIT packages:

```wit
// my-contract.wit
package myapp:token@1.0.0;

use wasi:http@0.2.0;           // External dependency
use starstream:ledger@0.1.0;   // Platform dependency

world token {
    import wasi:http/types@0.2.0;
    export transfer: func(to: string, amount: u64) -> result<_, error>;
}
```

When a WASM Component is compiled, these dependencies get **flattened** into the component binary. The resulting component contains all the type information from all its dependencies, bundled together.


#### WIT Flattening Proof-of-Concept

The following code demonstrates how to programmatically flatten WIT files with their dependencies into a single output:

```rust
use anyhow::bail;
use std::path::Path;
use wit_encoder::{NestedPackage, packages_from_parsed};
use wit_parser::{PackageId, Resolve};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Parse all WIT files into a Resolve
    let (resolve, main_package) = get_resolve(Path::new("wit"))?;
    let result = flatten_wit_files(&resolve)?;

    Ok(())
}

fn get_resolve(path: &Path) -> anyhow::Result<(Resolve, PackageId)> {
    let mut resolve = Resolve::new();
    let (main, _) = resolve.push_dir(path)?;
    Ok((resolve, main))
}

fn flatten_wit_files(resolve: &Resolve) -> anyhow::Result<String> {
    // Convert Resolve to wit-encoder Package structures
    let packages = packages_from_parsed(&resolve);

    if packages.is_empty() {
        bail!("no packages found");
    }

    let mut output = String::new();

    // All packages as nested packages
    for package in packages.iter() {
        let mut nested = NestedPackage::new(package.name().clone());
        // Copy all items from the original package to nested
        for item in package.items() {
            nested.item(item.clone());
        }
        output.push_str(&nested.to_string());
        output.push_str("\n");
    }
    Ok(output)
}
```

**Key dependencies**: `wit-parser`, `wit-encoder`

### The Scaling Problem

Consider a blockchain with millions of UTXOs:

1. **Many contracts share common dependencies** - almost every contract imports `wasi:http`, `starstream:ledger`, etc.
2. **Each UTXO stores a flattened WIT** - the same dependency types are repeated millions of times
3. **Contract hashes are unique per component** - even if two contracts import identical dependencies, their contract hashes differ (because the component code differs)

**Current approach (problematic)**:
```
Registry: HashMap<ContractHash, ComponentInterface>

Contract A (hash: 0xAAA...) → "package a:foo; use wasi:http@0.2.0; use wasi:cli@0.2.0; ..."
Contract B (hash: 0xBBB...) → "package b:bar; use wasi:http@0.2.0; use wasi:cli@0.2.0; ..."
Contract C (hash: 0xCCC...) → "package c:baz; use wasi:http@0.2.0; use wasi:cli@0.2.0; ..."
                              ↑ Same dependencies repeated millions of times!
```

### The Solution: Content-Addressable WIT Package Storage

Instead of storing the full flattened WIT for each contract, we want:

```
Registry: HashMap<ContractHash, Vec<WitPackageHash>>
PackageStore: HashMap<WitPackageHash, Package>

Contract A (hash: 0xAAA...) → [0xPKG1, 0xPKG2, 0xPKG3]  // Just references
Contract B (hash: 0xBBB...) → [0xPKG1, 0xPKG2, 0xPKG4]  // Shares 0xPKG1, 0xPKG2
Contract C (hash: 0xCCC...) → [0xPKG1, 0xPKG2, 0xPKG5]  // Shares 0xPKG1, 0xPKG2

PackageStore:
  0xPKG1 → wasi:http@0.2.0 (stored once!)
  0xPKG2 → wasi:cli@0.2.0 (stored once!)
  0xPKG3 → a:foo@1.0.0
  0xPKG4 → b:bar@1.0.0
  0xPKG5 → c:baz@1.0.0
```

**Key insight**: A single UTXO's flattened WIT decomposes into multiple independent WIT packages, each identified by its content hash (`WitPackageHash`). Common dependencies are stored once and referenced many times.

#### WIT Format Constraints for Content-Addressable Storage

When storing WIT packages for content addressing, we must consider two WIT syntax forms:

1. **Semicolon format** (standard for single-package files):
   ```wit
   package foo:bar@1.0.0;
   interface baz { test: func(); }
   ```

2. **Nested format** (for multi-package documents):
   ```wit
   package foo:bar@1.0.0 {
     interface baz { test: func(); }
   }
   ```

Both standards are usable as the input to the hash function, and we must choose which one is best.

---

## Design Requirements

| Requirement | Description | Priority |
|-------------|-------------|----------|
| **Browser Compatibility** | Run entirely in-browser without filesystem access (see below) | Critical |
| **Content Integrity** | Verify package contents haven't been modified or corrupted | Critical |
| **Decentralized Identity** | Identify packages by content hash, not by name (names can be spoofed) | Critical |
| **Deduplication** | Store identical packages once, even when referenced by millions of UTXOs | High |
| **Lazy Loading** | Only fetch/load packages when actually needed to minimize memory/disk usage | High |
| **Offline Resolution** | Resolve all dependencies without network access after initial sync | High |
| **Standard Tool Compatibility** | Act as a registry consumable by existing package managers (wit-deps, wkg, etc.) | High |
| **Topological Ordering** | Maintain correct load order for dependencies with inter-dependencies | Medium |

### Browser Compatibility Requirement

**The entire Starstream blockchain node—including the registry—must be runnable in the browser.** This is a hard requirement, not a nice-to-have.

**Implications:**

1. **No filesystem access**: Browsers don't have traditional filesystem APIs. All storage must use abstractions that can be backed by in-memory storage, IndexedDB, or other browser-compatible mechanisms.

2. **Storage trait abstraction**: The registry uses a `Storage` trait that can be implemented by:
   - `InMemoryStorage` (works everywhere, including browsers)
   - Filesystem storage (desktop/server only)
   - IndexedDB storage (browser-specific)
   - Any K-V store

3. **HTTP interfaces still work**: Even though the registry runs in-browser, we can still expose HTTP-compatible interfaces. Service workers can intercept HTTP requests, allowing tools like `wit-deps` (which expect HTTP URLs) to work against an in-browser registry.

```
┌─────────────────────────────────────────────────────────┐
│ Browser                                                 │
│  ┌──────────────┐    intercept    ┌─────────────────┐  │
│  │ wit-deps     │ ──────────────► │ Service Worker  │  │
│  │ (HTTP fetch) │                 │                 │  │
│  └──────────────┘                 └────────┬────────┘  │
│                                            │           │
│                                            ▼           │
│                                   ┌─────────────────┐  │
│                                   │ In-Browser      │  │
│                                   │ Registry        │  │
│                                   │ (InMemoryStorage│  │
│                                   │  or IndexedDB)  │  │
│                                   └─────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

This architecture allows us to maintain compatibility with standard WIT tooling while running entirely in the browser.

### Storage Architecture Options

We need a storage layer that works across multiple environments (browsers/WASM and desktop/server). This section documents the options considered.

#### Storage Format Options

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Simple K-V** | Keys are strings (e.g., `pkg:{hash}`), values are raw bytes | Simple, portable, easy to implement for any backend | No built-in structure, no standard ecosystem |
| **OCI CAS** | Content-Addressable Storage per OCI Distribution Spec | Industry standard, `wkg`/wasm-pkg-tools compatible, well-defined layout | Designed for container images, may be overkill, complex spec |
| **IPFS CID** | Content Identifiers with self-describing hash | Enables IPFS distribution, self-describing format, content-routing built-in | Adds complexity, requires IPFS integration, CID overhead |
| **SQLite** | Embedded SQL database | ACID transactions, complex queries, works in WASM (sql.js) | Heavier dependency, may be overkill for simple K-V needs |

**Current choice**: Simple K-V storage. Rationale:
- Minimal complexity for initial implementation
- Easy to implement for any backend (memory, IndexedDB, filesystem)
- Can layer OCI/IPFS-compatible APIs on top later if needed
- Dependencies form a graph, but we don't need Merkle trees for our current use case (hash verification is per-package, not per-tree)

#### Critical: Data Ownership and Availability

**The node MUST own all WIT package data.** We cannot rely on external sources (IPFS nodes, OCI registries, etc.) to provide WIT files at runtime.

**Why**: Data withholding attacks. If a contract's WIT depends on data from an external source, an attacker could:
1. Publish a contract with WIT referencing external data
2. Later make that external data unavailable
3. The blockchain halts because nodes can't resolve the WIT and don't know how to proceed

**Implications**:

| Role | Allowed | Not Allowed |
|------|---------|-------------|
| **Server** | Expose our data via OCI/IPFS protocols | - |
| **Client** | Fetch from other Starstream nodes | Fetch from external IPFS/OCI registries |
| **Storage** | Use OCI/IPFS data layouts internally | Rely on external storage availability |

**We are the authoritative source.** Other tools (wit-deps, wkg, IPFS clients) can fetch FROM our nodes, but our nodes never fetch WIT data from external non-Starstream sources.

#### WIT Syntax Does NOT Support Remote URLs

A potential concern is whether WIT syntax itself could reference external URLs, enabling data withholding attacks - for example `git: https://github.com/example/foo`. **It cannot.**

The [WIT specification](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) uses **logical package identifiers**, not URLs

```
┌─────────────────────────────────────────────────────────────┐
│ Starstream Node (authoritative data owner)                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ PackageStore (all WIT data stored locally)          │   │
│  └──────────────────────┬──────────────────────────────┘   │
│                         │                                   │
│         ┌───────────────┼───────────────┐                  │
│         ▼               ▼               ▼                  │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐           │
│  │ HTTP API   │  │ IPFS API   │  │ OCI API    │           │
│  │ (wit-deps) │  │ (optional) │  │ (wkg)      │           │
│  └─────┬──────┘  └─────┬──────┘  └─────┬──────┘           │
└────────┼───────────────┼───────────────┼────────────────────┘
         │               │               │
         ▼               ▼               ▼
    External clients fetch FROM us (we never fetch FROM them)
```

**Future consideration**: We may expose OCI or IPFS-compatible APIs so external tools can fetch packages from our nodes. This is purely for interoperability—the node remains the authoritative owner of all data.

#### Storage Trait Options

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **Custom trait** | Define our own `Storage` trait | Full control, tailored to our needs, no external dependencies | Must write our own implementations, no ecosystem reuse |
| **Industry standard trait** | Use an existing abstract storage trait | Ecosystem compatibility, existing implementations | Few popular options exist, may not fit our needs exactly |

**Analysis of existing traits**:

| Crate/Trait | Description | WASM Support | Fit |
|-------------|-------------|--------------|-----|
| `object_store` (Apache Arrow) | Cloud storage abstraction (S3, GCS, Azure) | Limited | Poor - focused on cloud, not local/browser |
| `wit-deps::Cache` | URL-centric caching for wit-deps | Unknown | Poor - URL-centric, not content-addressed |
| `kv` crate | Abstract K-V store | No | Poor - not WASM compatible |
| `sled` | Embedded database | No | Poor - not WASM compatible |
| `async-trait` based custom | Roll our own | Yes | Good - full control |

**Current choice**: Custom `Storage` trait. Rationale:
- No dominant industry-standard trait exists for cross-platform (native + WASM) abstract storage
- Using a non-popular trait doesn't save work and may add constraints
- Our needs are minimal (put, get, exists) - easy to implement
- We control the trait, so we can evolve it as requirements change
- We can always add adapters to standard formats later

**Our `Storage` trait**:

```rust
pub trait Storage: Send + Sync {
    fn put(&self, key: StorageKey, value: Vec<u8>) -> impl Future<Output = Result<(), StorageError>>;
    fn get(&self, key: &str) -> impl Future<Output = Result<Vec<u8>, StorageError>>;
    fn exists(&self, key: &str) -> impl Future<Output = bool>;
}
```

**Design notes**:
- **No `delete`**: Blockchain data is immutable—once a package is stored, it cannot be removed.
- **No `list_keys`**: Would be a DOS vector with millions of entries. Instead, we track package hashes explicitly (e.g., `Vec<WitPackageHash>` per contract) rather than enumerating storage.

**Planned implementations**:

| Backend | Environment | Status | Notes |
|---------|-------------|--------|-------|
| `InMemoryStorage` | All | Done | HashMap-based, ephemeral |
| `IndexedDbStorage` | Browser | Future | Persistent browser storage |
| `FileSystemStorage` | Desktop/Server | Future | For development/testing |

**Future API layers** (expose data TO external tools, not fetch FROM external sources):

| API Layer | Purpose | Notes |
|-----------|---------|-------|
| HTTP/Tarball | wit-deps compatibility | Serve packages as gzipped tarballs |
| OCI Distribution | wkg/cargo-component compatibility | Serve as OCI registry endpoint |
| IPFS Gateway | IPFS tooling compatibility | Serve via IPFS protocol (we are the source) |

#### Storage Format: Text vs Binary Encoding

**Critical decision: Store WIT as text, not binary.**

The `wit-component` crate provides a binary encoding via `encode()` that produces deterministic WebAssembly binary output. This seems attractive for content-addressable storage. However, **binary encoding is unsafe for long-term blockchain storage**.

**The risk**: The component model binary format is still evolving toward a 1.0 release and has undergone [breaking changes](https://github.com/WebAssembly/component-model/issues/193). From the component-model repository:

> "the binary format has undergone breaking changes relative to previously implemented and accepted syntax"

**Why this matters for Starstream**:

| Concern | Impact |
|---------|--------|
| **Data longevity** | Blockchain data stored today must be readable 10+ years from now |
| **Version pinning** | Pinning to a specific `wit-component` version forever is not realistic |
| **Multi-version bundling** | Bundling every version of wit-tools to try different decodings is impractical |
| **Contract bricking** | If binary decoding fails, contracts become unusable |

**The WIT text format is the specification.** It's what developers write, what documentation references, and what tools are designed to parse. While individual parsers may have bugs, the text format itself is stable and human-readable—if a parser fails, humans can still read the WIT.

**Our approach**:

```
┌─────────────────────────────────────────────────────────────────┐
│ WIT Processing Pipeline                                          │
│                                                                   │
│  Component bytes                                                  │
│       │                                                           │
│       ▼                                                           │
│  wit_component::decode() → Resolve                                │
│       │                                                           │
│       ▼                                                           │
│  Extract packages, rewrite versions with hash                     │
│       │                                                           │
│       ▼                                                           │
│  WitPrinter → Text representation                                 │
│       │                                                           │
│       ├──► Hash text → WitPackageHash (for content addressing)    │
│       │                                                           │
│       └──► Store text (for persistence)                           │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

| Step | Format | Purpose |
|------|--------|---------|
| Parsing | Binary → Resolve | Use `wit-component` to parse incoming components |
| Hashing | Text → SHA-256 | Content-addressable identity |
| Storage | Text | Long-term persistence (stable format) |
| Serving | Text | Human-readable, tool-compatible |

**Trade-offs accepted**:
- Text is larger than binary (acceptable: WIT files are small, storage is cheap)
- `WitPrinter` output may vary between versions (only affects NEW packages, not stored data)
- Hashing text requires deterministic formatting (verify `WitPrinter` determinism)

**Why not hash the binary but store text?** This would create a mismatch: the stored content wouldn't match its hash if binary encoding changed. By hashing what we store (text), we maintain consistency.

#### Caching Considerations

Some K-V stores (like Redis) keep all data in memory. This won't work for Starstream at scale—we may have millions of packages, and keeping them all in memory is impractical.

**Future hybrid approach**: A caching layer that keeps frequently-accessed packages in memory while storing the full dataset in persistent storage:

```
┌─────────────────────────────────────────────────────────┐
│                    PackageStore                          │
│  ┌─────────────────┐     ┌─────────────────────────┐   │
│  │  Hot Cache      │     │  Cold Storage           │   │
│  │  (InMemory)     │ ◄─► │  (IndexedDB/Filesystem) │   │
│  │  - Recent pkgs  │     │  - All packages         │   │
│  │  - Popular deps │     │  - Persistence          │   │
│  └─────────────────┘     └─────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

This could be implemented as a `CachedStorage<H, C>` wrapper that composes a hot (in-memory) and cold (persistent) backend, with LRU eviction for the hot cache.

#### Dependency Graph Considerations

WIT packages form a dependency graph, but we don't currently need Merkle tree structures because:

1. **Integrity is per-package**: Each package is hashed independently; we verify integrity on load
2. **Dependencies are explicit**: The `Vec<WitPackageHash>` for each contract explicitly lists all dependencies
3. **No incremental sync needed (yet)**: We don't currently need to efficiently sync partial trees

If we later need features like:
- Efficient partial sync (only fetch changed subtrees)
- Cryptographic proof that a package belongs to a contract's dependency set
- IPFS-style content routing

...then we may want to adopt Merkle DAG structures (like IPFS) or similar. This would be an additive change to the storage layer, not a replacement.

## Registry Interoperability Requirement

A key design goal is that our system should be **usable as a package registry** by at least one standard WebAssembly tooling ecosystem. This enables dApp developers to:

1. **Pull Starstream type definitions** using familiar tools (`wkg`, `wit-deps`, or similar)
2. **Integrate with existing build systems** that expect standard package manager interfaces
3. **Use IDE integrations** that already support WIT tooling

### Why This Matters for Starstream

The client crate (`node-client`) demonstrates how dApps interact with contracts:

```rust
// Compile-time bindings (preferred for dApps)
mod bindings {
    wasmtime::component::bindgen!({
        path: "../node-server/genesis/wit/no-args/wit"
    });
}
let bindings = bindings::Root::instantiate_async(&mut store, &component, &linker).await?;
let result = bindings.call_get_value(&mut store)?;  // Type-safe!
```

For dApp developers to use compile-time bindings, they need access to the WIT files for the contracts they want to interact with. Our registry should allow them to fetch these WIT definitions using standard tooling.

### Target Compatibility Options

| Tool | Protocol/Interface | Compatibility Path |
|------|---------------------|-------------------|
| **wit-deps** | HTTP URLs + TOML manifest | Serve packages as gzipped tarballs at predictable URLs |
| **wkg** (wasm-pkg-tools) | `PackageLoader` trait, OCI, Warg | Implement `PackageLoader` trait or serve OCI-compatible endpoints |
| **cargo-component** | Uses wkg internally | Compatible via wkg integration |

### Minimum Viable Registry Interface

At minimum, our system should expose:

1. **Package Discovery**: Given a contract hash, return the list of `WitPackageHash` values
2. **Package Retrieval**: Given a `WitPackageHash`, return the package content
3. **Integrity Verification**: All responses must include or be verifiable against content hashes

---

## Why We Cannot Use `PackageName` Alone

`PackageName` (namespace + name + version, e.g., `wasi:http@0.2.0`) seems like a natural stable identifier:

```rust
pub struct PackageName {
    pub namespace: String,       // e.g., "wasi"
    pub name: String,            // e.g., "http"
    pub version: Option<Version> // e.g., Some("0.2.0")
}
```

**The problem**: In a decentralized system without a central registry, a malicious actor could create a package with the same `PackageName` but different (malicious) contents. Unlike centralized registries (npm, crates.io, warg) that enforce uniqueness of names, Starstream has no such authority.

| Scenario | Risk |
|----------|------|
| Centralized registry | Registry enforces `wasi:http@0.2.0` is unique |
| Starstream (decentralized) | Anyone can claim their package is `wasi:http@0.2.0` |

## The Solution: Content-Addressable Storage

The solution is **content-addressable storage**, where each package is identified by the cryptographic hash of its canonical binary representation. This is similar to how Git identifies commits, or how IPFS identifies content.

**Key Properties**:
- **Same content → same hash**: Regardless of who claims to own the package or what name they give it
- **Different content → different hash**: Any modification (malicious or otherwise) produces a completely different identifier
- **Hash serves dual purpose**: Both identity (what package is this?) and integrity (has it been modified?)
- **Natural deduplication**: Store once, reference many times by hash

---

## Security Considerations

### Storage Backend Attacks

When implementing storage backends (especially filesystem-based), be aware of potential denial-of-service vectors:

**Hash-prefix bucket attacks**: Some storage systems (like git) use the first few characters of a hash as a directory prefix for sharding (e.g., `ab/abcdef123...`). An attacker could deliberately craft many packages whose hashes share the same prefix, causing one "bucket" to become disproportionately large and slow.

| Storage Type | Vulnerability | Mitigation |
|--------------|---------------|------------|
| In-memory (HashMap) | None - O(1) lookup regardless of key distribution | N/A |
| Filesystem with prefix sharding | Slow directory listing/access if one prefix is overloaded | Avoid prefix-based sharding, or use full hash as filename |
| K-V store | Depends on implementation | Use storage with uniform key distribution |

**Current implementation**: The `PackageStore` uses flat keys (`pkg:{full_hash}`) without any prefix-based sharding, avoiding this attack vector. The `InMemoryStorage` backend uses a HashMap with O(1) average-case lookups.

**Future filesystem backends**: If implementing a filesystem storage backend, avoid git-style prefix sharding. Instead, use the full hash as the filename, or use a storage system that handles key distribution uniformly (like a proper K-V store or content-addressable filesystem).

**Economic mitigation**: On the actual Starstream ledger, storage fees make large-scale hash-collision attacks expensive. However, this should not be relied upon as the sole defense—the storage layer should be robust against adversarial key distributions regardless.

---

## Advanced Concerns

The following problems are fundamental challenges that affect the long-term design but may be too complex to solve in the initial implementation. We document them here to ensure our initial design doesn't preclude future solutions.

### 1. Transitive Content Addressing Problem

Content-addressable storage works well at a single level: we hash a package's content and use that hash as its identifier. However, **WIT packages reference their dependencies by name, not by hash**.

**The problem**:
```wit
// Package A declares a dependency by name
package myapp:token@1.0.0;
use wasi:http@0.2.0;  // References by name, not by hash!
```

When we hash `myapp:token@1.0.0`, the hash includes the *text* `use wasi:http@0.2.0`, not the actual content of `wasi:http`. This creates ambiguity:

```
Scenario: Two different packages both claim to be wasi:http@0.2.0

PackageStore:
  0xAAA → wasi:http@0.2.0 (legitimate)
  0xBBB → wasi:http@0.2.0 (malicious clone with same name)

myapp:token depends on "wasi:http@0.2.0"
  → Which hash should be used? 0xAAA or 0xBBB?
```

**Why this is hard**: WIT's syntax uses human-readable names for dependencies. To make hashes truly transitive, we'd need either:
1. A canonical mapping from names to hashes (requires central authority - defeats decentralization)
2. Modify WIT syntax to reference dependencies by hash (breaks ecosystem compatibility)
3. Embed the hash in the version string itself (our approach)

### Solution: Semver Build Metadata

Semver supports **build metadata** via the `+` suffix. This metadata is ignored for version precedence but is part of the version string:

```
1.2.3+buildmeta     ← standard semver with build metadata
1.2.3+abc.def       ← multiple segments separated by dots
```

**Our approach**: The ledger rewrites package imports to embed the content hash in the build metadata:

```wit
// Original (ambiguous)
use wasi:http@0.2.0;

// After ledger rewriting (unambiguous)
// Full SHA-256 hash (64 hex chars) required for cryptographic security
use wasi:http@0.2.0+a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2;
```

The hash in the build metadata makes the reference **transitively content-addressed**: the same version string now uniquely identifies both the package name AND its exact content.

**Handling existing build metadata**: Some packages may already have build metadata. In this case, append the hash with a `.` separator:

```wit
// Original with existing build metadata
use example:lib@1.0.0+nightly;

// After ledger rewriting
use example:lib@1.0.0+nightly.a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2;
```

**Implementation**: When a new component is registered:
1. Extract all WIT packages from the flattened component
2. For each package, compute its content hash
3. Rewrite all version strings to include the hash in build metadata
4. Re-encode and store the modified packages

**Benefits**:
- Fully backwards-compatible with semver parsers
- Human-readable names preserved (debugging, tooling)
- Hash provides unambiguous identity
- No central authority required
- Standard WIT syntax (no custom extensions)

**Trade-off**: The rewritten WIT files differ from the originals and are verbose. Clients must understand that `wasi:http@0.2.0` in their source code becomes `wasi:http@0.2.0+<64-hex-char-hash>` in the registry. This is similar to how lock files work in other package managers.

### 2. Hierarchy Problem: Packages vs Interfaces vs Types

WIT has a hierarchy: **Packages** contain **Interfaces** which contain **Types** and **Functions**. Different use cases require depending on different levels of this hierarchy.

**The problem**: Smart contracts often care about *interfaces* or *types*, not whole packages.

```wit
// wasi:http package contains multiple interfaces
package wasi:http@0.2.0;

interface types {
    record request { ... }
    record response { ... }
}

interface incoming-handler {
    use types.{request, response};
    handle: func(req: request) -> response;
}

interface outgoing-handler {
    use types.{request, response};
    send: func(req: request) -> response;
}
```

A contract might only need `wasi:http/types`, not the entire `wasi:http` package. Currently, we hash at the package level, forcing unnecessary coupling.

**Two competing needs**:

| Use Case | What Matters | Example |
|----------|--------------|---------|
| **Structural typing** | "Accept anything with this shape" | A DEX that accepts any token implementing `interface erc20 { balance: func() -> u64; transfer: func(...); }` |
| **Nominal typing** | "Must be this exact implementation" | A governance contract that only accepts the official `dao:voting-token@1.0.0`, not any structurally-equivalent token |

#### How the Component Model Handles This

The Component Model uses a **hybrid approach**: structural typing for most types, with nominal/generative behavior for resources.

**Structural types (default)**: All type constructors except `resource` are structural. Type equality is based on AST structure:
- `list<string>` equals `list<string>` regardless of how it's defined (inline, aliased, or nested)
- Records, variants, tuples, functions are all compared structurally
- The `(eq T)` bound explicitly requires structural equivalence

**Resource types (nominal/generative)**: Resources break from structural typing:
1. **Generative**: Each component instantiation creates fresh resource types distinct from all others—even from the same component definition
2. **Nominal within a component**: Each `resource` definition creates a new type distinct from all preceding types, even with identical structure

```
(type $r1 (resource (rep i32)))
(type $r2 (resource (rep i32)))
;; $r1 ≠ $r2 despite identical structure
```

**Type bounds** provide two options for imported/exported types:

| Bound | Behavior |
|-------|----------|
| `(eq T)` | Requires structural equivalence to T |
| `(sub resource)` | Introduces a fresh abstract type |

**Handle types** (`own<T>`, `borrow<T>`) are syntactically structural but inherit the freshness of their underlying resource.

*Reference: Component Model design/mvp/Explainer.md - "all type constructors are structural with the exception of resource, which is abstract and generative."*

#### Why This Is Still Hard for Starstream

Despite the Component Model's hybrid approach:
- **Interface-level identity**: WIT doesn't have a native concept of "interface hash" separate from "package hash"
- **Cross-component resources**: Resource freshness is per-instantiation, not per-definition, complicating content-addressed identity
- **Structural matching at scale**: Comparing interface shapes requires parsing and normalizing, not just hash comparison
- **Package-level granularity**: Our content-addressing currently operates at the package level, not interface or type level

**Impact on initial implementation**: For v1, we hash at the package level. This means:
- All contracts get nominal typing by default (same package hash = same types)
- Structural typing is not supported initially
- Contracts that only need one interface still pull in the whole package

**Future approaches**:

1. **Interface-level hashing**: Compute `InterfaceHash` in addition to `PackageHash`. Contracts could declare dependencies at either level.

2. **Structural type matching**: Build a separate index that maps interface shapes to packages implementing them. Query: "find all packages with an interface structurally matching this definition."

3. **Type-level addressing**: The most granular approach - hash individual type definitions. This enables maximum deduplication but adds significant complexity.

---

## Roadmap

This section tracks the phased approach to implementing the registry, acknowledging which problems we solve now vs later.

### Phase 1: Basic Content-Addressable Storage (Initial Implementation)

**Goal**: Deduplicate WIT packages across UTXOs using content hashes.

**Scope**:
- `HashMap<ContractHash, Vec<WitPackageHash>>` registry structure
- `HashMap<WitPackageHash, Package>` package store
- Package-level hashing using `wit-component::encode()` + SHA-256
- Extract and store all packages when a component is registered
- Resolve dependencies at ingestion time (name → hash mapping)

**Explicitly deferred**:
- [ ] Interface-level or type-level hashing
- [ ] Structural type matching
- [ ] External tooling compatibility (wit-deps, wkg)

### Phase 2: External Tool Compatibility

**Goal**: Enable dApp developers to fetch WIT definitions using standard tooling.

**Scope**:
- Serve packages via HTTP endpoints compatible with `wit-deps`
- Generate `deps.toml` / `deps.lock` files for contracts
- Consider OCI/Warg compatibility for `wkg` users

**Open questions**:
- [ ] Which tool ecosystem to prioritize (wit-deps vs wkg)?
- [ ] How to map content-addressed hashes to URL schemes?

### Phase 3: Advanced Type Resolution

**Goal**: Support both structural and nominal typing patterns.

**Scope**:
- Interface-level hashing (`InterfaceHash`)
- Structural type index for interface matching
- Query API: "find packages implementing interface X"

**Research needed**:
- [ ] Can we compute stable interface hashes independent of package context? This probably requires a more advanced tool on top of wit-parser, or recommending to people to create packages that hold just their interface (some kind of interface-only package pattern)

### Phase 4: Optimizations

**Goal**: Production-ready performance and storage efficiency.

**Scope**:
- Type-level deduplication (if Phase 3 shows benefit)
- Lazy loading and caching strategies
- Compression for on-chain storage
- Merkle tree proofs for light clients

---

# Implementation Approaches

The following documents describe three distinct implementation paths for achieving content-addressable WIT package storage. Each approach has different trade-offs regarding standardization, reusability, and external tool compatibility.

| Document | Approach | Summary |
|----------|----------|---------|
| `2.md` | Pure wasm-tools | Maximum control, minimal dependencies, custom hashing |
| `3.md` | wasm-pkg-tools | Full ecosystem compatibility, OCI/Warg support, `wkg` CLI compatible |
| `4.md` | wit-deps | Lightweight, URL-based, simple HTTP serving |
| `5.md` | Comparison & Recommendation | Summary matrix and hybrid approach recommendation |
