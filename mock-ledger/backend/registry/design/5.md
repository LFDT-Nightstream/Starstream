# Conclusion and Implementation Recommendation

This document synthesizes the analysis from approaches 1-3 and provides a concrete recommendation for Starstream's WIT package registry implementation.

---

## Context Recap

Starstream has specific requirements that differ from general-purpose WIT registries:

1. **Two distinct hash types**:
   - **Contract Hash** (Poseidon2): Identifies the full WASM Component on the blockchain
   - **WIT Package Hash** (SHA-256): Identifies individual WIT packages for deduplication

2. **Transitive content addressing solved**: We use **semver build metadata** to embed full SHA-256 hashes in version strings (e.g., `wasi:http@0.2.0+<64-hex-chars>`), making dependency references unambiguous without breaking ecosystem compatibility. The full hash is required for cryptographic security—truncation would enable birthday attacks.

3. **WIT text output**: We use `WitPrinter::print_package()` from `wit-component` to produce canonical text representation. Note: `wit-encoder::packages_from_parsed()` cannot be used as it panics on worlds with inline types.

4. **WIT flattening available**: We have a proof-of-concept using `wit-encoder::NestedPackage` and `packages_from_parsed()` to decompose flattened components.


5. **Browser compatibility required**: The entire node (including registry) must run in browsers. This drove the decision to use a custom `Storage` trait abstraction rather than filesystem-based storage.

6. **Phased roadmap**: Initial implementation focuses on deduplication; external tooling and advanced type resolution come later.

### Storage Architecture Decision

See [1.md § Storage Architecture Options](1.md#storage-architecture-options) for full analysis.

**Summary of decisions**:

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **Storage format** | Simple K-V | Minimal complexity, easy to implement for any backend, can add OCI/IPFS later |
| **Storage trait** | Custom `Storage` trait | No industry-standard cross-platform (native + WASM) trait exists |
| **Merkle trees** | Not needed (yet) | Per-package hashing sufficient; explicit `Vec<WitPackageHash>` for dependencies |
| **Content encoding** | **Text (not binary)** | Binary format unstable; blockchain data must be readable forever |

### Critical: Text Storage for Long-Term Stability

**We store WIT packages as text, not binary.** See [1.md § Storage Format: Text vs Binary Encoding](1.md#storage-format-text-vs-binary-encoding) for detailed rationale.

The `wit-component::encode()` binary format is still evolving and has undergone [breaking changes](https://github.com/WebAssembly/component-model/issues/193). For a blockchain where data must be readable 10+ years from now, this is unacceptable risk.

**Pipeline**:
1. Parse component bytes via `wit_component::decode()` → `Resolve`
2. Extract packages, rewrite versions with content hashes
3. Convert to text via `WitPrinter`
4. Hash the text → `WitPackageHash`
5. Store the text

By hashing what we store (text), we maintain consistency between content and identity.

### WIT Text Format: Semicolon vs Nested

WIT has two syntax forms for package declarations. We store packages in **semicolon format**:

```wit
// What we store (semicolon format - self-contained)
package wasi:http@0.2.0;
interface types { ... }
```

Not nested format:
```wit
// NOT what we store (nested format - cannot parse individually)
package wasi:http@0.2.0 {
  interface types { ... }
}
```

**Rationale**:

| Factor | Semicolon | Nested |
|--------|-----------|--------|
| Parse individually | ✅ `Resolve::push_str()` works | ❌ "no package header found" |
| Developer familiarity | ✅ Standard .wit file format | Rarely used in source |
| Round-trip | ✅ Store → parse → modify → print | ❌ Cannot parse back |
| Combined output | ✅ `WitPrinter::print()` handles | N/A |

The hash represents **semantic identity**. Since both formats parse to identical `Resolve` structures, and `WitPrinter` produces deterministic output, the format choice doesn't affect deduplication—same semantic package → same hash.

Therefore, we store the WIT files as follows:
1. Convert to semicolon format
2. Compute the hash of the semicolon format
3. Add the semver build metadata (note: this is done *after* hashing to avoid the hash being self-referential)
4. Save to storage

If we need to convert the package to nested format to combine it with other packages, we can do the conversion while keeping the hash in the semver build metadata equal to the value from the semicolon format.

**Future storage backends** (can be added without changing `PackageStore`):

| Backend | Use Case |
|---------|----------|
| `IndexedDbStorage` | Persistent browser storage |
| `FileSystemStorage` | Desktop/server development |

**Future API layers** (serve data TO external tools—we are the authoritative source):

| API | Compatibility |
|-----|---------------|
| HTTP/Tarball | wit-deps |
| OCI Distribution | wkg, cargo-component |
| IPFS Gateway | IPFS tooling |

**Critical**: Nodes never fetch WIT data from external sources (IPFS, OCI registries). This prevents data withholding attacks. We only *serve* data via these protocols.

---

## Updated Comparison Matrix

| Feature | Approach 1 (Pure wasm-tools) | Approach 2 (wasm-pkg-tools) | Approach 3 (wit-deps) | Starstream Requirement |
|---------|------------------------------|-----------------------------|-----------------------|------------------------|
| **Content addressing** | Custom SHA-256 | `ContentDigest` (SHA-256) | `Digest` (SHA-256 + SHA-512) | SHA-256 of **text** (not binary) |
| **Semver build metadata support** | Manual implementation | Would need extension | Would need extension | **Critical for Phase 1** |
| **WIT encoding/decoding** | `wit-component::decode` + `WitPrinter` | Via `wit-component` | Via `wit-component` | Text output for storage |
| **Flattening support** | Manual with `wit-encoder` | Not built-in | Not built-in | We have PoC |
| **External tool compat** | None | `wkg` CLI, OCI, Warg | `wit-deps` CLI | Phase 2 concern |
| **Lock file format** | Custom JSON | `wkg.lock` (TOML) | `deps.lock` (TOML) | Phase 2 concern |
| **Streaming validation** | Manual | `validating_stream()` | `DigestReader/Writer` | Nice to have |
| **Complexity** | High (full control) | Medium | Low | Prefer simpler |
| **Dependencies** | Minimal | Many crates | Single crate | Prefer minimal |

---

## Analysis by Phase

### Phase 1: Basic Content-Addressable Storage

**Goal**: Deduplicate WIT packages across UTXOs.

**What we need**:
1. Extract packages from flattened WIT using `wit-encoder`
2. Rewrite version strings to include hash in build metadata
3. Convert to text via `WitPrinter`, compute SHA-256 hash of text
4. Store text by hash, map contract hash → `Vec<WitPackageHash>`

**Approach evaluation**:

| Approach | Fit for Phase 1 | Rationale |
|----------|-----------------|-----------|
| **Approach 1** | **Best** | Direct use of `wit-component`, no abstraction overhead, full control over semver rewriting |
| Approach 2 | Overkill | Registry protocols, OCI/Warg support not needed yet |
| Approach 3 | Partial fit | Lock file format useful, but URL-centric design doesn't match our content-first model |

**Recommendation for Phase 1**: **Approach 1 (Pure wasm-tools)** with selective borrowing from Approach 3.

Specifically:
- Use `wit-component::decode()` to parse incoming components into `Resolve`
- Use `wit-encoder::packages_from_parsed()` for package extraction
- Implement custom version rewriting for semver build metadata
- Use `WitPrinter` to convert to text format for storage and hashing
- **Store text, not binary** - the binary format is unstable long-term

### Phase 2: External Tool Compatibility

**Goal**: Enable dApp developers to fetch WIT definitions using standard tooling.

**What we need**:
1. HTTP endpoints serving packages as tarballs
2. Compatibility with either `wit-deps` or `wkg` manifest formats
3. Discovery mechanism (package name + version → content hash)
4. **Browser support via service workers** (see below)

**Approach evaluation**:

| Approach | Fit for Phase 2 | Rationale |
|----------|-----------------|-----------|
| Approach 1 | Insufficient | No external tool integration |
| **Approach 2** | **Good** | `PackageLoader` trait makes us a first-class registry backend |
| **Approach 3** | **Good** | HTTP tarball serving is straightforward, `deps.lock` format works |

**Recommendation for Phase 2**: **Hybrid of Approaches 2 and 3**.

- Serve HTTP tarball endpoints (wit-deps compatible)
- Optionally implement `PackageLoader` trait (wasm-pkg-tools compatible)
- Use TOML lock files (compatible with both ecosystems)

**Browser compatibility via Service Workers**:

Since Starstream nodes run in-browser, we need HTTP endpoints to work without a traditional server. Service workers can intercept HTTP requests and serve responses from the in-browser registry:

```
┌─────────────────────────────────────────────────────────┐
│ Browser                                                 │
│  ┌──────────────┐    intercept    ┌─────────────────┐  │
│  │ wit-deps     │ ──────────────► │ Service Worker  │  │
│  │ fetch(url)   │                 │                 │  │
│  └──────────────┘                 └────────┬────────┘  │
│                                            │           │
│                                            ▼           │
│                                   ┌─────────────────┐  │
│                                   │ PackageStore    │  │
│                                   │ (InMemoryStorage│  │
│                                   │  or IndexedDB)  │  │
│                                   └─────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

This allows tools expecting HTTP URLs (like `wit-deps`) to work against an in-browser registry. The service worker translates HTTP requests into `PackageStore` lookups.

### Phase 3+: Advanced Type Resolution

These phases require research and are out of scope for initial implementation. The approaches don't differ significantly here—all would require custom extensions.

---

## Concrete Implementation Plan

### Phase 1 Implementation Steps

```
1. Storage abstraction (DONE)
   ├── Storage trait (backend-agnostic interface)
   ├── InMemoryStorage (browser-compatible, testing)
   └── Future: IndexedDB, filesystem, K-V stores

2. PackageStore (content-addressable storage) (DONE)
   ├── store(content: &[u8]) -> WitPackageHash
   ├── load(hash: &WitPackageHash) -> Vec<u8>
   └── Generic over Storage backend

3. VersionRewriter (semver build metadata) (DONE)
   ├── version_with_hash(version: &Version, hash: &WitPackageHash) -> Version
   │   // 0.2.0 → 0.2.0+a1b2c3d4e5f6...(64 hex chars)
   │   // 0.2.0+nightly → 0.2.0+nightly.a1b2c3d4e5f6...(64 hex chars)
   ├── extract_hash_from_version(version: &Version) -> Option<WitPackageHash>
   └── strip_hash_from_version(version: &Version) -> Version

4. ComponentRegistry (contract hash → packages mapping) (DONE)
   ├── register(contract_hash: String, component_bytes: &[u8])
   │   ├── Decode component using wit-component::decode()
   │   ├── Extract packages (iterate resolve.packages)
   │   ├── For each package:
   │   │   ├── Convert to text via WitPrinter
   │   │   ├── Store text in PackageStore (returns hash)
   │   │   └── Collect hash
   │   └── Store Vec<WitPackageHash> for contract
   │
   ├── get_packages(contract_hash: String) -> Vec<WitPackageHash>
   ├── get_wit(contract_hash: String) -> String  // With hash in version
   └── get_wit_raw(contract_hash: String) -> String  // Original text

5. Integration with existing Registry (DONE)
   ├── Registry now wraps ComponentRegistry<InMemoryStorage>
   ├── register(contract_hash, component_bytes, entrypoint) - takes raw bytes
   ├── get_wit(contract_hash, resolve) - returns ComponentInterface
   ├── get_wit_raw(contract_hash) - returns raw WIT without hash rewriting
   ├── get_packages(contract_hash) - returns Vec<WitPackageHash>
   └── Ledger updated to pass component_bytes directly (no more extract_wit)
```

### Key Code Structures

```rust
/// Content-addressable hash for a WIT package (SHA-256 of TEXT representation)
#[derive(Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WitPackageHash([u8; 32]);

impl WitPackageHash {
    /// Compute hash from text content (what we store)
    pub fn from_bytes(bytes: &[u8]) -> Self {
        Self(Sha256::digest(bytes).into())
    }

    pub fn to_build_metadata(&self) -> String {
        // Full 32 bytes = 64 hex chars required for cryptographic security
        // Truncation would enable birthday attacks (~2^32 ops for 64-bit truncation)
        hex::encode(&self.0)
    }

    pub fn to_hex(&self) -> String { hex::encode(self.0) }
    pub fn from_hex(s: &str) -> Result<Self, hex::FromHexError> { ... }
}

/// Rewrite a version to include the package hash
pub fn version_with_hash(version: &Version, hash: &WitPackageHash) -> Result<Version, VersionError> {
    let hash_str = hash.to_build_metadata();
    let new_build = if version.build.is_empty() {
        hash_str
    } else {
        format!("{}.{}", version.build, hash_str)
    };
    let build_metadata = BuildMetadata::new(&new_build)?;
    Ok(Version { build: build_metadata, ..version.clone() })
}

/// Extract hash from version's build metadata
pub fn extract_hash_from_version(version: &Version) -> Option<WitPackageHash> { ... }

/// Strip hash from version for clean display
pub fn strip_hash_from_version(version: &Version) -> Version { ... }
```

**Note**: We hash the TEXT representation, not binary. This ensures:
1. Stored content matches its hash (both are text)
2. Long-term stability (text format is the WIT spec, binary format may change)

### File Structure

```
registry/
├── src/
│   ├── lib.rs              # Existing Registry (updated to use new internals)
│   ├── store.rs            # PackageStore (content-addressable)
│   ├── hash.rs             # WitPackageHash type
│   ├── version.rs          # Version rewriting logic
│   ├── flatten.rs          # WIT flattening using wit-encoder
│   └── component.rs        # ComponentRegistry (contract → packages)
├── design/
│   ├── 1.md                # Problem statement & Starstream context
│   ├── 2.md                # Approach 1: Pure wasm-tools
│   ├── 3.md                # Approach 2: wasm-pkg-tools
│   ├── 4.md                # Approach 3: wit-deps
│   └── 5.md                # This conclusion
└── wit/
    └── registry.wit        # WIT interface (update for new capabilities)
```

---

## Dependencies to Add

```toml
# Cargo.toml additions for Phase 1
[dependencies]
wit-component = "0.243"     # Encode/decode WIT packages
wit-encoder = "0.243"       # Package extraction and manipulation
wit-parser = "0.243"        # Parse WIT for Resolve
sha2 = "0.10"               # SHA-256 hashing
hex = "0.4"                 # Hex encoding for hashes
semver = "1.0"              # Version manipulation
```

---

## Summary

| Phase | Approach | Key Deliverables |
|-------|----------|------------------|
| **Phase 1** | Approach 1 (Pure wasm-tools) | `PackageStore`, `WitPackageHash`, version rewriting, `ComponentRegistry` |
| **Phase 2** | Hybrid (2 + 3) | HTTP tarball endpoints, lock file generation, `PackageLoader` trait |
| **Phase 3+** | Custom extensions | Interface-level hashing, structural matching (requires research) |

**Bottom line**: Start with Approach 1 for maximum control and minimal complexity. The semver build metadata solution for transitive content addressing is the key insight that makes this approach viable. External tooling compatibility can be added incrementally in Phase 2 without architectural changes—we just need to expose our content-addressable store via standard protocols.
