# Implementation plan

- See [Starstream language specification](docs/language-spec.md) for details on the language currently implemented.
- See [Codebase structure](./README.md#codebase-structure) for details on the components in this repository.

## TODOs

Components:

- [x] define grammar
- [x] strip down parser and ast - @rvcas
- [x] revamp snapshot test organization - @rvcas
- [x] ditch op codes and make a tree-walking interpreter (ast nodes) - @SpaceManiac
- [x] compile stripped down lang to wasm - @SpaceManiac
- [x] single-binary CLI - @SpaceManiac
- [x] formatter, including snapshot tests, included in CLI - @rvcas
- [x] tree sitter grammar - @SpaceManiac
- [x] type system setup
  - [x] basics specs - @SpaceManiac
  - [x] return lsp diagnostics to be displayed in editor - @rvcas
  - [x] [Algorithm W](https://sdiehl.github.io/typechecker-zoo/algorithm-w/lambda-calculus.html) and typed AST - @rvcas
- [x] LSP server, included in CLI - @rvcas
- [x] vscode extension (incl. highlighting and LSP launcher) - @SpaceManiac dogfooding
  - [x] run LSP with `cargo run`
  - [x] compile & use wasm LSP
- [x] web sandbox - @SpaceManiac
  - [x] basic editor
  - [x] highlighting and LSP via VSC web ext
  - [x] compile to Wasm and show disassembly
  - [ ] when language has some form of print(), run reference interpreter
  - [ ] when Wasm ABI is known enough, run Wasm module
- [x] zed extension - @rvcas dogfooding

Language features:

- [x] `else if`
- [x] functions
- [x] function call expressions
- [x] if expressions
- [x] block expressions
- [x] make `let` const and add `let mut`
- [x] type annotations on `let` bindings
- [x] coordination script exports
- [ ] mock ledger
  - [ ] sandbox shows current "input" ledger state (starts empty)
  - [ ] sandbox allows calling coordination scripts with arguments, can pass existing UTXOs as input (JS console?)
  - [ ] sandbox shows "output" ledger state after running, with "save" button that copies it to the "input"
- [x] base-level ABI stuff
  - [x] underlying callable ABI
- [ ] `abi` elements
  - [ ] plain methods
  - [ ] errors
    - [ ] throw(?) expr
    - [ ] fail the transaction
  - [x] events
    - [x] declarations
    - [x] emit expr
    - [ ] displayed as part of run output in sandbox and elsewhere
  - [ ] effects
    - [ ] declarations
    - [ ] raise expr
    - [ ] try/with blocks
- [x] `runtime` expr for system imports
- [ ] UTXO elements
  - [x] `storage` blocks to declare UTXO state (Wasm globals)
  - [x] basic `main fn`s
  - [ ] private method `fn`s
  - [ ] public method `pub fn`s ?
  - [ ] abi impl blocks
  - [ ] coroutine support (yield/resume)
- [ ] UTXO handles
  - [ ] generic `Utxo` handle
  - [ ] `utxo UtxoName` handle types
  - [ ] `abi AbiName` handle types
  - [ ] table-driven provable downcasting
- [ ] tokens stuff
- [ ] standard integer primitive types
  - [x] `bool`
  - [x] (i|u)(8|16|32|64)
  - [ ] `char` (is it u32 or `Field<21>`?)
  - ~~`f32` and `f64`~~ (determinism/proving trouble)
  - [x] literals infer their type from context
- [ ] variable privacy
  - [ ] `disclose` builtin
  - [ ] check that `if` conditions are disclosed
  - [ ] check that variables across yield points are disclosed
- [ ] typedefs
  - [ ] basic `type A = B;`
  - [ ] export `pub type A = B;` to WIT
- [ ] linear/affine typing
- [x] struct types
  - remember structural typing (see spec)
  - [x] tuples
  - [x] wasm codegen support as WIT records
- [x] enum (tagged union) types
  - [x] wasm codegen support as WIT variants
  - [x] builtin `Option<T>`, `Result<T, E>` (WIT support)
- [x] patterns and pattern matching
  - exhaustive patterns in arguments?
  - [x] support literals in pattern
  - [ ] patterns in `let` LHS (structs make sense, enums not so much)
  - [x] exhaustiveness checking for `match`
  - [ ] improve diagnostics for pattern/type mismatches
  - [ ] flag inconsistent `match` arm return values (fallthrough semantics)
- [ ] heap types
  - maybe defer until components support GC?
  - [ ] `string` and string literals (WIT support)
  - [ ] builtin container `List<T>` (WIT support)
- [ ] extra WIT functionality
  - [ ] owned and borrowed resource handles
  - [ ] flags types
  - [ ] declare intent to export a particular WIT world, compiler errors if it's not satisfied
- [ ] imports
  - [x] import hardcoded WIT declarations for runtime functions
  - [ ] import externals from arbitrary .wit files
    - how to advertise the need for these to be fulfilled by a runtime extension?
    - [ ] by path
    - [ ] by WIT package expression, follows standard(?) search path
  - [ ] embed library code from component .wasm
  - [ ] import utxo, tokens, and script fns from other Starstream contracts
  - [ ] embed `library fn`s from other `.star` files
- [ ] fields and foreign field arithmetic (important for interop)
  - maybe `Field<N>` or `Int<N>`, `UInt<N>`
  - how to implement?

Research:

- try out [Verus](https://github.com/verus-lang/verus) as a way to verify the reference interpreter
- specify (roughly) the Wasm ABI that the compiler must target (maybe use WIT?)
  - this is what [`lookups`](../lookups) takes as input.
  - Wasm + the rough shape of external calls
    - how resource types (utxos, tokens) are named
    - how freestanding functions are named
- library/module/interop stuff
  - import `./another_file.star`
  - import `./external_module.wasm` (wasm target only?)
  - JavaScript bindings (WIT?) so dApps can call into Starstream contracts compiled to Wasm
- debugger
- proving and ZK
  - memory consistency checks (or how to handle memory)
  - lookups
